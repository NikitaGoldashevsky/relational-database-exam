**Билет 40. Оптимизация запросов**

### Правила создания индексов
- Индексируй **часто используемые в `WHERE`, `JOIN`, `ORDER BY`** столбцы.
- Для составных условий — **составной индекс** по нескольким полям.
- Избегай избыточных индексов: они замедляют запись и занимают место.

### Просмотр индексов (PostgreSQL)
```sql
-- Список индексов таблицы
\d table_name

-- Через системный каталог
SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'table_name';
```
Формат: имя индекса, тип (B-tree, GIN и т.д.), список столбцов.

### Составной vs простой индекс
- **Простой**: ускоряет фильтрацию по одному столбцу.
- **Составной** (`(col1, col2)`): эффективен для запросов по `col1`, или `col1 + col2`, но **не по `col2` отдельно**.  
  Порядок важен: наиболее селективный — первым.

### План выполнения
```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT ...;
```
Показывает: метод доступа (Seq Scan vs Index Scan), стоимость, время, использованные индексы.

### Статистика и `ANALYZE`
- PostgreSQL собирает статистику о распределении данных (частота значений, количество строк).
- Команда:  
  ```sql
  ANALYZE table_name;  -- обновляет статистику
  ```
- **Назначение**: оптимизатор использует статистику для выбора наилучшего плана (например, использовать ли индекс).

> ⚠️ Без актуальной статистики оптимизатор может выбрать неэффективный план.
