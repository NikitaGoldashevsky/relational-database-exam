**Билет 38. Триггеры в языке SQL (PostgreSQL)**

### Общая структура и назначение
Триггер — процедура, автоматически вызываемая при событии (`INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`).  
- **`BEFORE`** — до изменения данных (можно изменить данные строки или отменить операцию).  
- **`AFTER`** — после изменения (для логирования, каскадных действий).  
- **`INSTEAD OF`** — только для представлений (заменяет операцию).

### `FOR EACH ROW` vs `FOR EACH STATEMENT`
- **`FOR EACH ROW`**: триггер вызывается **для каждой затронутой строки**.  
  Доступны псевдопеременные `NEW` (новая строка) и `OLD` (старая строка).
- **`FOR EACH STATEMENT`**: вызывается **один раз на весь запрос**, даже если затронуто 0 строк.  
  Переменные `NEW`/`OLD` недоступны.

### Синтаксис создания (PostgreSQL)
1. Создаётся **функция-обработчик** (на PL/pgSQL или другом языке).  
2. Создаётся **триггер**, ссылающийся на эту функцию.

### Пример: запрет удаления активных пользователей
```sql
-- 1. Функция-обработчик
CREATE OR REPLACE FUNCTION prevent_active_user_delete()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF OLD.active = TRUE THEN
    RAISE EXCEPTION 'Нельзя удалять активного пользователя с id=%', OLD.id;
  END IF;
  RETURN OLD; -- обязательно для BEFORE DELETE
END;
$$;

-- 2. Триггер
CREATE TRIGGER tr_prevent_active_delete
BEFORE DELETE ON users
FOR EACH ROW
EXECUTE FUNCTION prevent_active_user_delete();
```

### Сообщение об ошибке
В PostgreSQL используется:  
```sql
RAISE EXCEPTION 'сообщение';
```
— это прерывает транзакцию и откатывает изменения.

Триггеры мощны, но требуют осторожности: они скрыты от основного потока выполнения и могут снижать производительность.
